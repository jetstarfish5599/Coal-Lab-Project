TITLE Bordered Snake Game (MASM / Irvine32)
;Project by Masoom Khan, Dev Kumar, and Sagbatullah
INCLUDE Irvine32.inc

; Game boundaries
MIN_X = 1
MAX_X = 78
MIN_Y = 1
MAX_Y = 23
MAX_LENGTH = 200                ;Max snake length

;Direction constants
DIR_RIGHT = 0
DIR_LEFT  = 1
DIR_UP    = 2
DIR_DOWN  = 3

.data
;Game state variables
snakeBody    COORD MAX_LENGTH dup( <> ) ;Array of snake segments
snakeLength  DWORD 5                ;Initial length
snakeDirection DWORD DIR_RIGHT        ;Initial direction
foodPosition COORD <>               ;Food's location
score        DWORD 0
gameOver     DWORD 0                ;0 = playing, 1 = game over
gameDelay    DWORD 100              ;Game speed in ms
oldTail      COORD <>               ;Stores last tail position for erasing
ateFoodFlag  DWORD 0                ;Flag for eating

;Game characters
snakeChar    BYTE 'O'
foodChar     BYTE '@'
borderChar   BYTE '#'
scoreMsg     BYTE "Score: ",0
gameOverMsg1 BYTE "Game Over!",0
gameOverMsg2 BYTE "Press any key to exit.",0

.code
main PROC
    call InitializeGame         ;Set up initial variables

gameLoop:
    cmp gameOver, 1             ;Check if game over
    je  showGameOverScreen      ;If yes, exit loop

    ;Main game tick
    call HandleInput            ;Check for player key press
    call UpdateGame             ;Update game logic (move, collisions)
    call DrawGame               ;Redraw the snake
    mov  eax, gameDelay
    call Delay                  ;Pause to control speed
    jmp  gameLoop               ;Repeat

showGameOverScreen:
    call DisplayGameOver        ;Show "Game Over"
    
    ;FIX: Use ReadChar instead of WaitMsg.
    ;WaitMsg automatically prints "Press any key to continue...", which conflicts
    ;with our custom "Press any key to exit." message.
    ;ReadChar waits for input silently.
    call ReadChar
    
    exit                        ;Exit program
main ENDP


;InitializeGame PROC
;Sets up the initial state of the game
InitializeGame PROC
    push ebp
    mov  ebp, esp

    call ClrScr
    call Randomize              ;Seed random number generator
    
    ;Set default game state
    mov  gameOver, 0
    mov  score, 0
    mov  snakeLength, 5
    mov  snakeDirection, DIR_RIGHT

    ;Create the initial snake body
    mov  snakeBody[0 * TYPE COORD].X, 10
    mov  snakeBody[0 * TYPE COORD].Y, 10
    mov  snakeBody[1 * TYPE COORD].X, 9
    mov  snakeBody[1 * TYPE COORD].Y, 10
    mov  snakeBody[2 * TYPE COORD].X, 8
    mov  snakeBody[2 * TYPE COORD].Y, 10
    mov  snakeBody[3 * TYPE COORD].X, 7
    mov  snakeBody[3 * TYPE COORD].Y, 10
    mov  snakeBody[4 * TYPE COORD].X, 6
    mov  snakeBody[4 * TYPE COORD].Y, 10

    call DrawBorder             ;Draw play area
    call PlaceFood              ;Place first food
    call UpdateScoreDisplay     ;Show score

    pop  ebp
    ret
InitializeGame ENDP


;HandleInput PROC
;Checks for user input (arrow keys)
HandleInput PROC
    push ebp
    mov  ebp, esp
    push eax
    push edx

    call ReadKey                ;Check for key press (non-blocking)
    cmp  eax, 0
    je   no_input               ;No key pressed, exit

    ;Key was pressed, check arrow keys
    cmp  ah, 48h                ;up arrow
    je   tryUp
    cmp  ah, 50h                ;down arrow
    je   tryDown
    cmp  ah, 4Bh                ;left arrow
    je   tryLeft
    cmp  ah, 4Dh                ;right arrow
    je   tryRight
    jmp  no_input               ;Not an arrow key

tryUp:
    mov  edx, snakeDirection
    cmp  edx, DIR_DOWN          ;Prevent 180-degree turn
    je   no_input
    mov  snakeDirection, DIR_UP
    jmp  no_input

tryDown:
    mov  edx, snakeDirection
    cmp  edx, DIR_UP            ;Prevent 180-degree turn
    je   no_input
    mov  snakeDirection, DIR_DOWN
    jmp  no_input

tryLeft:
    mov  edx, snakeDirection
    cmp  edx, DIR_RIGHT         ;Prevent 180-degree turn
    je   no_input
    mov  snakeDirection, DIR_LEFT
    jmp  no_input

tryRight:
    mov  edx, snakeDirection
    cmp  edx, DIR_LEFT          ;Prevent 180-degree turn
    je   no_input
    mov  snakeDirection, DIR_RIGHT

no_input:
    pop  edx
    pop  eax
    pop  ebp
    ret
HandleInput ENDP


;UpdateGame PROC
;Main game logic hub for each frame
UpdateGame PROC
    push ebp
    mov  ebp, esp

    call UpdateSnake            ;Move snake
    call CheckFoodCollision     ;Check for eating
    call CheckWallCollision     ;Check wall collision
    call CheckSelfCollision     ;Check self-collision

    pop  ebp
    ret
UpdateGame ENDP


;UpdateSnake PROC
;Moves the snake by shifting the body array
UpdateSnake PROC
    push ebp
    mov  ebp, esp
    pushad                      ;Save all registers

    ;Save the last tail segment's position
    ;We'll erase it later if we don't eat
    mov  ecx, snakeLength
    dec  ecx
    mov  esi, OFFSET snakeBody
    lea  esi, [esi + (ecx * TYPE COORD)] ;esi = &snakeBody[snakeLength-1]
    mov  ax, (COORD PTR [esi]).X
    mov  bx, (COORD PTR [esi]).Y
    mov  oldTail.X, ax
    mov  oldTail.Y, bx

    ;Move the snake body: body[i] = body[i-1]
    ;Must be done from tail-to-head
    mov  ecx, snakeLength
    dec  ecx
    jz   moveHead               ;Skip if length is 1

    lea  edi, [esi]             ;edi = &snakeBody[snakeLength-1]
    lea  esi, [esi - TYPE COORD];esi = &snakeBody[snakeLength-2]
    
    std                         ;Set direction flag (high to low)
    rep movsd                   ;Move segments
    cld                         ;Clear direction flag

moveHead:
    ;Calculate the new head position
    mov  esi, OFFSET snakeBody  ;esi = &snakeBody[0] (head)
    mov  ax, (COORD PTR [esi]).X
    mov  bx, (COORD PTR [esi]).Y

    ;Update head based on direction
    mov  ecx, snakeDirection
    cmp  ecx, DIR_RIGHT
    je   moveRight
    cmp  ecx, DIR_LEFT
    je   moveLeft
    cmp  ecx, DIR_UP
    je   moveUp
    cmp  ecx, DIR_DOWN
    je   moveDown

moveRight:
    inc  ax                     ;X + 1
    jmp  setNewHead
moveLeft:
    dec  ax                     ;X - 1
    jmp  setNewHead
moveUp:
    dec  bx                     ;Y - 1
    jmp  setNewHead
moveDown:
    inc  bx                     ;Y + 1

setNewHead:
    mov  (COORD PTR [esi]).X, ax ;Save new head X
    mov  (COORD PTR [esi]).Y, bx ;Save new head Y

    popad                       ;Restore all registers
    pop  ebp
    ret
UpdateSnake ENDP


;CheckFoodCollision PROC
;Checks if the snake head is on the food
CheckFoodCollision PROC
    push ebp
    mov  ebp, esp
    pushad

    mov  ateFoodFlag, 0         ;Reset flag

    mov  esi, OFFSET snakeBody  ;Get head position
    mov  ax, (COORD PTR [esi]).X
    mov  bx, (COORD PTR [esi]).Y

    cmp  ax, foodPosition.X     ;Compare head.X to food.X
    jne  noEat
    cmp  bx, foodPosition.Y     ;Compare head.Y to food.Y
    jne  noEat

    ;ATE FOOD
    mov  ateFoodFlag, 1         ;Set flag (don't erase tail)
    inc  snakeLength            ;Increase snake's length

    ;Connect the new tail segment to the snake
    ;Set new tail pos = oldTail pos
    push esi
    push edi
    push ecx
    push ax
    push bx

    mov  ecx, snakeLength
    dec  ecx                    ;ecx = new tail index
    mov  esi, OFFSET snakeBody
    lea  edi, [esi + (ecx * TYPE COORD)] ;edi = address of new tail
    
    mov  ax, oldTail.X          ;Get pos of the tail we left
    mov  bx, oldTail.Y
    
    mov  (COORD PTR [edi]).X, ax ;Set new tail's X
    mov  (COORD PTR [edi]).Y, bx ;Set new tail's Y

    pop  bx
    pop  ax
    pop  ecx
    pop  edi
    pop  esi

    add  score, 10              ;Add 10 points

    ;HARD MODE: Speed up the game
    cmp gameDelay, 30           ;Check if we're at max speed (30ms)
    jle skipSpeedUp             ;If yes, don't speed up more
    sub gameDelay, 5            ;If no, get 5ms faster

skipSpeedUp:
    call UpdateScoreDisplay
    call PlaceFood              ;Place new food

noEat:
    popad
    pop  ebp
    ret
CheckFoodCollision ENDP


;CheckWallCollision PROC
;Checks if the snake head hit the border
CheckWallCollision PROC
    push ebp
    mov  ebp, esp
    pushad

    mov  esi, OFFSET snakeBody  ;Get head position
    mov  ax, (COORD PTR [esi]).X
    mov  bx, (COORD PTR [esi]).Y

    ;UPDATED LOGIC:
    ;We use 'jle' (less or equal) and 'jge' (greater or equal)
    ;so the game ends instantly if you touch the wall coordinate.
    
    cmp  ax, MIN_X              ;Hit left wall?
    jle  setGameOver            ;IF X <= MIN_X -> DIE
    
    cmp  ax, MAX_X              ;Hit right wall?
    jge  setGameOver            ;IF X >= MAX_X -> DIE
    
    cmp  bx, MIN_Y              ;Hit top wall?
    jle  setGameOver            ;IF Y <= MIN_Y -> DIE
    
    cmp  bx, MAX_Y              ;Hit bottom wall?
    jge  setGameOver            ;IF Y >= MAX_Y -> DIE
    
    jmp  noWallCollision

setGameOver:
    mov  gameOver, 1            ;Set flag to 1

noWallCollision:
    popad
    pop  ebp
    ret
CheckWallCollision ENDP


;CheckSelfCollision PROC
;Checks if the snake head hit its own body
CheckSelfCollision PROC
    push ebp
    mov  ebp, esp
    pushad

    mov  esi, OFFSET snakeBody  ;Get head position
    mov  ax, (COORD PTR [esi]).X
    mov  bx, (COORD PTR [esi]).Y

    ;Loop through the rest of the body
    add  esi, TYPE COORD        ;esi = &snakeBody[1]
    mov  ecx, snakeLength
    dec  ecx                    ;Loop snakeLength - 1 times

    cmp  ecx, 0                 ;No body to check
    je   noSelfCollision

checkLoop:
    cmp  ax, (COORD PTR [esi]).X ;head.X == body[i].X?
    jne  nextSegment
    cmp  bx, (COORD PTR [esi]).Y ;head.Y == body[i].Y?
    jne  nextSegment

    ;Collision detected
    mov  gameOver, 1
    jmp  noSelfCollision

nextSegment:
    add  esi, TYPE COORD        ;Move to next segment
    loop checkLoop

noSelfCollision:
    popad
    pop  ebp
    ret
CheckSelfCollision ENDP


;PlaceFood PROC
;Finds a valid random spot for new food
PlaceFood PROC
    push ebp
    mov  ebp, esp
    pushad

spawnLoop:
    ;Get random X (inside border)
    mov  eax, MAX_X - MIN_X - 1
    call RandomRange
    add  eax, MIN_X + 1
    mov  foodPosition.X, ax

    ;Get random Y (inside border)
    mov  eax, MAX_Y - MIN_Y - 1
    call RandomRange
    add  eax, MIN_Y + 1
    mov  foodPosition.Y, ax

    ;Load new food coords
    mov  ax, foodPosition.X
    mov  bx, foodPosition.Y
    
    ;Check if food spawned on the snake
    mov  ecx, snakeLength
    mov  esi, OFFSET snakeBody
checkSnakePos:
    cmp  ax, (COORD PTR [esi]).X ;food.X == snake[i].X?
    jne  posOK
    cmp  bx, (COORD PTR [esi]).Y ;food.Y == snake[i].Y?
    jne  posOK
    
    ;Invalid position, try again
    jmp  spawnLoop

posOK:
    add  esi, TYPE COORD
    loop checkSnakePos

    ;Valid position, draw the food
    mov  ax, foodPosition.Y
    mov  dh, al
    mov  ax, foodPosition.X
    mov  dl, al
    call Gotoxy
    
    mov  al, foodChar
    call WriteChar
    
    popad
    pop  ebp
    ret
PlaceFood ENDP


;DrawGame PROC
;Main drawing procedure
DrawGame PROC
    push ebp
    mov  ebp, esp
    pushad

    ;Draw the new head
    mov  esi, OFFSET snakeBody
    mov  ax, (COORD PTR [esi]).Y
    mov  dh, al
    mov  ax, (COORD PTR [esi]).X
    mov  dl, al
    call Gotoxy
    mov  al, snakeChar
    call WriteChar

    ;Erase the old tail, unless we just ate
    cmp  ateFoodFlag, 1
    je   skipErase               ;Ate food, don't erase (this grows snake)

    ;Didn't eat, so erase last tail segment
    mov  ax, oldTail.Y
    mov  dh, al
    mov  ax, oldTail.X
    mov  dl, al
    call Gotoxy
    mov  al, ' '                ;Draw a blank space
    call WriteChar

skipErase:
    popad
    pop  ebp
    ret
DrawGame ENDP


;DrawBorder PROC
;Draws the boundary walls
DrawBorder PROC
    push ebp
    mov  ebp, esp
    pushad
    
    mov  al, borderChar

    ;Draw top and bottom walls
    mov  ecx, MAX_X - MIN_X + 1
    mov  dl, MIN_X
    mov  dh, MIN_Y
    call Gotoxy
drawTop:
    call WriteChar
    loop drawTop
    
    mov  dl, MIN_X
    mov  dh, MAX_Y
    call Gotoxy
    mov  ecx, MAX_X - MIN_X + 1
drawBottom:
    call WriteChar
    loop drawBottom

    ;Draw left and right walls
    mov  ecx, MAX_Y - MIN_Y - 1
    mov  dl, MIN_X
    mov  dh, MIN_Y + 1
    call Gotoxy
drawLeft:
    call WriteChar
    inc  dh
    call Gotoxy
    loop drawLeft

    mov  ecx, MAX_Y - MIN_Y - 1
    mov  dl, MAX_X
    mov  dh, MIN_Y + 1
    call Gotoxy
drawRight:
    call WriteChar
    inc  dh
    call Gotoxy
    loop drawRight

    popad
    pop  ebp
    ret
DrawBorder ENDP


;UpdateScoreDisplay PROC
;Writes the current score to the screen
UpdateScoreDisplay PROC
    push ebp
    mov  ebp, esp
    pushad
    
    mov  dh, 0                  ;Top-left corner
    mov  dl, 0
    call Gotoxy
    mov  edx, OFFSET scoreMsg
    call WriteString
    mov  eax, score
    call WriteDec
    
    ;FIX: Use WriteChar to print spaces instead of accidentally re-printing "Score:"
    mov  al, ' '
    call WriteChar
    call WriteChar             ;Write spaces to ensure old digits are cleared
    
    popad
    pop  ebp
    ret
UpdateScoreDisplay ENDP


;DisplayGameOver PROC
;Shows the game over message
DisplayGameOver PROC
    push ebp
    mov  ebp, esp
    pushad
    
    ;Position message in the middle
    mov  dh, 10
    mov  dl, 30
    call Gotoxy
    mov  edx, OFFSET gameOverMsg1
    call WriteString

    mov  dh, 11
    mov  dl, 25
    call Gotoxy
    mov  edx, OFFSET gameOverMsg2
    call WriteString
    
    popad
    pop  ebp
    ret
DisplayGameOver ENDP

END main
